import { Arguments } from './types/Commands';
interface ProbabilityResult {
    prediction: number;
    estimates: Array<{
        label: number;
        probability: number;
    }>;
}
export declare class SVM {
    private predict_one;
    private predict_one_probability;
    private add_instance;
    private create_svm_nodes;
    private train_problem;
    private svm_get_nr_sv;
    private svm_get_nr_class;
    private svm_get_sv_indices;
    private svm_get_labels;
    private svm_free_model;
    private svm_cross_validation;
    private svm_get_svr_probability;
    private free_problem;
    private serialize_model;
    private deserialize_model;
    private options;
    private model;
    private deserialized;
    private problem;
    private loaded;
    private libsvm;
    constructor(options: Arguments);
    loadASM(): Promise<SVM>;
    /**
     * Loads the WASM libsvm asynchronously, this is best for browser usage
     */
    loadWASM(): Promise<SVM>;
    /**
     * Trains a model
     * @param args
     */
    train(args: {
        samples: number[][];
        labels: number[];
    }): void;
    /**
     * Predict using a single vector of sample
     * @param args
     */
    predictOne(args: {
        sample: number[];
    }): number;
    /**
     * Predict a matrix
     * @param args
     */
    predict(args: {
        samples: number[][];
    }): number[];
    /**
     * Predict the label with probability estimate of many samples.
     * @param args
     */
    predictProbability(args: {
        samples: number[][];
    }): ProbabilityResult[];
    /**
     * Predict the label with probability estimate.
     * @param args
     */
    predictOneProbability(args: {
        sample: number[];
    }): ProbabilityResult;
    /**
     * Predict a regression value with a confidence interval
     * @param args
     */
    predictOneInterval(args: {
        sample: number[];
        confidence: number;
    }): {
        predicted: number;
        interval: number[];
    };
    /**
     * Predict regression values with confidence intervals
     * @param args
     */
    predictInterval(args: {
        samples: number[][];
        confidence: number;
    }): Array<{
        predicted: number;
        interval: number[];
    }>;
    /**
     * Get the array of labels from the model. Useful when creating an SVM instance with SVM.load
     */
    getLabels(): number[];
    /**
     * Save the state of the SVM
     */
    toJSON(): {
        model: number;
        options: Arguments;
        loaded: boolean;
        problem: number;
    };
    /**
     * Load a model from a state
     * @param args
     */
    fromJSON(args: {
        model: number;
        problem: number;
        options: Arguments;
        loaded: boolean;
    }): void;
    /**
     * Performs k-fold cross-validation (KF-CV). KF-CV separates the data-set into kFold random equally sized partitions,
     * and uses each as a validation set, with all other partitions used in the training set. Observations left over
     * from if kFold does not divide the number of observations are left out of the cross-validation process. If
     * kFold is one, this is equivalent to a leave-on-out cross-validation
     * @param args
     */
    crossValidation(args: {
        samples: number[][];
        labels: number[];
        kFold: number;
    }): {}[];
    /**
     * Get the indices of the support vectors from the training set passed to the train method.
     */
    getSVIndices(): number[];
    /**
     * Uses libsvm's serialization method of the model.
     */
    serializeModel(): any;
    /**
     * Free the memory allocated for the model. Since this memory is stored in the memory model of emscripten, it is
     * allocated within an ArrayBuffer and WILL NOT BE GARBARGE COLLECTED, you have to explicitly free it. So
     * not calling this will result in memory leaks. As of today in the browser, there is no way to hook the
     * garbage collection of the SVM object to free it automatically.
     * Free the memory that was created by the compiled libsvm library to.
     * store the model. This model is reused every time the predict method is called.
     */
    free(): void;
    private initiateAPIs;
    private getCommand;
    private createProblem;
    private getIntArrayFromModel;
    private getInterval;
}
export {};
