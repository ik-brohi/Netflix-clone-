"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-ignore: Emscripten starting point ASM
var libsvm_1 = __importDefault(require("../out/asm/libsvm"));
// @ts-ignore: Emscripten starting point for WASM
var libsvm_2 = __importDefault(require("../out/wasm/libsvm"));
var Errors_1 = require("./Errors");
var Commands_1 = require("./types/Commands");
var Util_1 = require("./Util");
var SVM = /** @class */ (function () {
    function SVM(options) {
        if (Commands_1.SVMTypes.indexOf(options.type) === -1) {
            throw Errors_1.SVMError("SVM cannot instantiate with an unknown type " + options.type);
        }
        if (Commands_1.KernelTypes.indexOf(options.kernel) === -1) {
            throw Errors_1.SVMError("SVM cannot instantiate with an unknown kernel " + options.kernel);
        }
        this.options = options;
        this.model = null;
        this.loaded = false;
    }
    SVM.prototype.loadASM = function () {
        var _this = this;
        return libsvm_1.default
            .load()
            .then(function () {
            if (_this.loaded) {
                throw Errors_1.SVMError('Cannot load an already loaded SVM');
            }
            _this.libsvm = libsvm_1.default;
            _this.initiateAPIs(_this.libsvm);
            _this.loaded = true;
            return _this;
        })
            .catch(function (err) {
            throw Errors_1.WASMError(err);
        });
    };
    /**
     * Loads the WASM libsvm asynchronously, this is best for browser usage
     */
    SVM.prototype.loadWASM = function () {
        var _this = this;
        return libsvm_2.default
            .load()
            .then(function () {
            if (_this.loaded) {
                throw Errors_1.SVMError('Cannot load an already loaded SVM');
            }
            _this.libsvm = libsvm_2.default;
            _this.initiateAPIs(_this.libsvm);
            _this.loaded = true;
            return _this;
        })
            .catch(function (err) {
            throw Errors_1.WASMError(err);
        });
    };
    /**
     * Trains a model
     * @param args
     */
    SVM.prototype.train = function (args) {
        if (this.deserialized) {
            throw Errors_1.SVMError('Cannot train a deserialized model');
        }
        this.free();
        this.problem = this.createProblem(args);
        var command = this.getCommand({ samples: args.samples });
        this.model = this.train_problem(this.problem, command);
    };
    /**
     * Predict using a single vector of sample
     * @param args
     */
    SVM.prototype.predictOne = function (args) {
        var sample = args.sample;
        if (!this.model) {
            throw Errors_1.SVMError('SVM cannot perform predictOne unless you instantiate it');
        }
        return this.predict_one(this.model, new Uint8Array(new Float64Array(sample).buffer), sample.length);
    };
    /**
     * Predict a matrix
     * @param args
     */
    SVM.prototype.predict = function (args) {
        var samples = args.samples;
        var arr = [];
        for (var i = 0; i < samples.length; i++) {
            arr.push(this.predictOne({ sample: samples[i] }));
        }
        return arr;
    };
    /**
     * Predict the label with probability estimate of many samples.
     * @param args
     */
    SVM.prototype.predictProbability = function (args) {
        var samples = args.samples;
        var arr = [];
        for (var i = 0; i < samples.length; i++) {
            arr.push(this.predictOneProbability({ sample: samples[i] }));
        }
        return arr;
    };
    /**
     * Predict the label with probability estimate.
     * @param args
     */
    SVM.prototype.predictOneProbability = function (args) {
        var sample = args.sample;
        var labels = this.getLabels();
        var nbLabels = labels.length;
        var estimates = this.libsvm._malloc(nbLabels * 8);
        var prediction = this.predict_one_probability(this.model, new Uint8Array(new Float64Array(sample).buffer), sample.length, estimates);
        var estimatesArr = Array.from(this.libsvm.HEAPF64.subarray(estimates / 8, estimates / 8 + nbLabels));
        var result = {
            prediction: prediction,
            estimates: labels.map(function (label, idx) { return ({
                label: label,
                probability: estimatesArr[idx],
            }); }),
        };
        this.libsvm._free(estimates);
        return result;
    };
    /**
     * Predict a regression value with a confidence interval
     * @param args
     */
    SVM.prototype.predictOneInterval = function (args) {
        var sample = args.sample, confidence = args.confidence;
        var interval = this.getInterval({ confidence: confidence });
        var predicted = this.predictOne({ sample: sample });
        return {
            predicted: predicted,
            interval: [predicted - interval, predicted + interval],
        };
    };
    /**
     * Predict regression values with confidence intervals
     * @param args
     */
    SVM.prototype.predictInterval = function (args) {
        var samples = args.samples, confidence = args.confidence;
        var interval = this.getInterval({ confidence: confidence });
        var predicted = this.predict({ samples: samples });
        return predicted.map(function (pred) { return ({
            predicted: pred,
            interval: [pred - interval, pred + interval],
        }); });
    };
    /**
     * Get the array of labels from the model. Useful when creating an SVM instance with SVM.load
     */
    SVM.prototype.getLabels = function () {
        var nLabels = this.svm_get_nr_class(this.model);
        return this.getIntArrayFromModel({ fn: this.svm_get_labels, model: this.model, size: nLabels });
    };
    /**
     * Save the state of the SVM
     */
    SVM.prototype.toJSON = function () {
        return {
            model: this.model,
            options: this.options,
            loaded: this.loaded,
            problem: this.problem,
        };
    };
    /**
     * Load a model from a state
     * @param args
     */
    SVM.prototype.fromJSON = function (args) {
        var model = args.model, problem = args.problem, options = args.options, loaded = args.loaded;
        this.model = model;
        this.options = options;
        this.loaded = loaded;
        this.problem = problem;
    };
    /**
     * Performs k-fold cross-validation (KF-CV). KF-CV separates the data-set into kFold random equally sized partitions,
     * and uses each as a validation set, with all other partitions used in the training set. Observations left over
     * from if kFold does not divide the number of observations are left out of the cross-validation process. If
     * kFold is one, this is equivalent to a leave-on-out cross-validation
     * @param args
     */
    SVM.prototype.crossValidation = function (args) {
        var samples = args.samples, labels = args.labels, kFold = args.kFold;
        if (this.deserialized) {
            throw Errors_1.SVMError('Cannot cross validate on an instance created with SVM.load');
        }
        var problem = this.createProblem({ samples: samples, labels: labels });
        var target = this.libsvm._malloc(labels.length * 8);
        this.svm_cross_validation(problem, this.getCommand({ samples: samples }), kFold, target);
        var data = this.libsvm.HEAPF64.subarray(target / 8, target / 8 + labels.length);
        var arr = Array.from(data);
        this.libsvm._free(target);
        this.free_problem(problem);
        return arr;
    };
    /**
     * Get the indices of the support vectors from the training set passed to the train method.
     */
    SVM.prototype.getSVIndices = function () {
        var nSV = this.svm_get_nr_sv(this.model);
        return this.getIntArrayFromModel({ fn: this.svm_get_sv_indices, model: this.model, size: nSV });
    };
    /**
     * Uses libsvm's serialization method of the model.
     */
    SVM.prototype.serializeModel = function () {
        if (!this.model) {
            throw Errors_1.SVMError('Cannot serialize model. No model was trained');
        }
        var result = this.serialize_model(this.model);
        var str = this.libsvm.Pointer_stringify(result);
        this.libsvm._free(result);
        return str;
    };
    /**
     * Free the memory allocated for the model. Since this memory is stored in the memory model of emscripten, it is
     * allocated within an ArrayBuffer and WILL NOT BE GARBARGE COLLECTED, you have to explicitly free it. So
     * not calling this will result in memory leaks. As of today in the browser, there is no way to hook the
     * garbage collection of the SVM object to free it automatically.
     * Free the memory that was created by the compiled libsvm library to.
     * store the model. This model is reused every time the predict method is called.
     */
    SVM.prototype.free = function () {
        if (this.problem) {
            this.free_problem(this.problem);
            this.problem = null;
        }
        if (this.model !== null) {
            this.svm_free_model(this.model);
            this.model = null;
        }
    };
    // @ts-ignore: Emscripten generated object is used as an input
    SVM.prototype.initiateAPIs = function (libsvm) {
        this.predict_one = libsvm.cwrap('libsvm_predict_one', 'number', ['number', 'array', 'number']);
        this.predict_one_probability = libsvm.cwrap('libsvm_predict_one_probability', 'number', [
            'number',
            'array',
            'number',
            'number',
        ]);
        this.add_instance = libsvm.cwrap('add_instance', null, ['number', 'array', 'number', 'number', 'number']);
        this.create_svm_nodes = libsvm.cwrap('create_svm_nodes', 'number', ['number', 'number']);
        this.train_problem = libsvm.cwrap('libsvm_train_problem', 'number', ['number', 'string']);
        this.svm_get_nr_sv = libsvm.cwrap('svm_get_nr_sv', 'number', ['number']);
        this.svm_get_nr_class = libsvm.cwrap('svm_get_nr_class', 'number', ['number']);
        this.svm_get_sv_indices = libsvm.cwrap('svm_get_sv_indices', null, ['number', 'number']);
        this.svm_get_labels = libsvm.cwrap('svm_get_labels', null, ['number', 'number']);
        this.svm_free_model = libsvm.cwrap('svm_free_model', null, ['number']);
        this.svm_cross_validation = libsvm.cwrap('libsvm_cross_validation', null, ['number', 'string', 'number', 'number']);
        this.svm_get_svr_probability = libsvm.cwrap('svm_get_svr_probability', 'number', ['number']);
        this.free_problem = libsvm.cwrap('free_problem', null, ['number']);
        this.serialize_model = libsvm.cwrap('serialize_model', 'number', ['number']);
        this.deserialize_model = libsvm.cwrap('deserialize_model', 'number', ['string']);
    };
    SVM.prototype.getCommand = function (args) {
        var samples = args.samples;
        var options = {};
        Object.assign(options, this.options, {
            gamma: this.options.gamma ? this.options.gamma : 1 / samples[0].length,
        });
        return Util_1.getCommand(options);
    };
    SVM.prototype.createProblem = function (args) {
        var samples = args.samples, labels = args.labels;
        var nbSamples = samples.length;
        var nbFeatures = labels.length;
        var problem = this.create_svm_nodes(nbSamples, nbFeatures);
        for (var i = 0; i < nbSamples; i++) {
            this.add_instance(problem, new Uint8Array(new Float64Array(samples[i]).buffer), nbFeatures, labels[i], i);
        }
        return problem;
    };
    SVM.prototype.getIntArrayFromModel = function (args) {
        var fn = args.fn, model = args.model, size = args.size;
        var offset = this.libsvm._malloc(size * 4);
        fn(model, offset);
        var data = this.libsvm.HEAP32.subarray(offset / 4, offset / 4 + size);
        // Casting any received from HEAP32 as number[]
        var arr = Array.from(data);
        this.libsvm._free(offset);
        return arr;
    };
    SVM.prototype.getInterval = function (args) {
        var confidence = args.confidence;
        var sigma = this.svm_get_svr_probability(this.model);
        if (sigma === 0) {
            throw Errors_1.SVMError('the model is not a regression with probability estimates');
        }
        if (confidence <= 0 || confidence >= 1) {
            throw Errors_1.SVMError('confidence must be greater than 0 and less than 1');
        }
        var p = (1 - confidence) / 2;
        return sigma * Math.sign(p - 0.5) * Math.log2(1 - 2 * Math.abs(p - 0.5));
    };
    return SVM;
}());
exports.SVM = SVM;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU1ZNLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL1NWTS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLDRDQUE0QztBQUM1Qyw2REFBb0M7QUFDcEMsaURBQWlEO0FBQ2pELDhEQUFzQztBQUN0QyxtQ0FBK0M7QUFDL0MsNkNBQW9FO0FBQ3BFLCtCQUFvQztBQVVwQztJQXdCRSxhQUFZLE9BQWtCO1FBQzVCLElBQUksbUJBQVEsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO1lBQ3pDLE1BQU0saUJBQVEsQ0FBQyxpREFBK0MsT0FBTyxDQUFDLElBQU0sQ0FBQyxDQUFDO1NBQy9FO1FBRUQsSUFBSSxzQkFBVyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7WUFDOUMsTUFBTSxpQkFBUSxDQUFDLG1EQUFpRCxPQUFPLENBQUMsTUFBUSxDQUFDLENBQUM7U0FDbkY7UUFFRCxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN2QixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztRQUNsQixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztJQUN0QixDQUFDO0lBRUQscUJBQU8sR0FBUDtRQUFBLGlCQWVDO1FBZEMsT0FBTyxnQkFBRzthQUNQLElBQUksRUFBRTthQUNOLElBQUksQ0FBQztZQUNKLElBQUksS0FBSSxDQUFDLE1BQU0sRUFBRTtnQkFDZixNQUFNLGlCQUFRLENBQUMsbUNBQW1DLENBQUMsQ0FBQzthQUNyRDtZQUNELEtBQUksQ0FBQyxNQUFNLEdBQUcsZ0JBQUcsQ0FBQztZQUNsQixLQUFJLENBQUMsWUFBWSxDQUFDLEtBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUMvQixLQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztZQUNuQixPQUFPLEtBQUksQ0FBQztRQUNkLENBQUMsQ0FB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